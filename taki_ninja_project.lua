	local p		= premake
    local taki 	= p.modules.taki
	local ninja = taki.ninja

	local u 	= dofile("utility.lua")

---
-- Add namespace for element definition lists for premake.callarray()
---

    ninja.elements = {}

--
-- Generate a GNU make C++ project makefile, with support for the new platforms API.
--

    ninja.elements.makefile = function(prj)
        return {
            ninja.header,
            --ninja.phonyRules,
            --ninja.shellType,
            ninja.outputConfigurationSection,
            ninja.outputTargetSection,
            --ninja.dependencies,
            --ninja.defaultconfig,
            ninja.eof,
        }
    end


    function ninja.generateProject(prj)
        p.eol("\n")
        p.callArray(ninja.elements.makefile, prj)
    end

---
-- Escape a string so it can be written to a ninja file.
---

    --[[
	function ninja.esc(value)
		value = value:gsub("%$", "$$")
		value = value:gsub(":", "$:")
		value = value:gsub("\n", "$\n")
		value = value:gsub(" ", "$ ")
		return value
	end
    --]]
    ninja.esc = taki.esc
    ninja.path = taki.path

--
-- Get the makefile file name for a workspace or a project. If this object is the
-- only one writing to a location then I can use "Makefile". If more than one object
-- writes to the same location I use name + ".make" to keep it unique.
--

	function ninja.getMakefileName(this, searchprjs)
		local count = 0
		for wks in p.global.eachWorkspace() do
			if wks.location == this.location then
				count = count + 1
			end

			if searchprjs then
				for _, prj in ipairs(wks.projects) do
					if prj.location == this.location then
						count = count + 1
					end
				end
			end
		end

		if count == 1 then
			return "build.ninja"
		else
			return ".ninja"
		end
	end


	--
	-- Output a makefile header.
	--
	-- @param target
	--    The workspace or project object for which the makefile is being generated.
	--

	function ninja.header(target)
		local prjKind = iif(target.project, "project", "workspace")

		_p('# %s %s makefile autogenerated by Premake', p.action.current().shortname, prjKind)
		--_p('')

		--ninja.defaultconfig(target)
	end


	function ninja.eof(target)
		_p('')
	end

	--
	-- Rules for file ops based on the shell type. Can't use defines and $@ because
	-- it screws up the escaping of spaces and parethesis (anyone know a fix?)
	--

	function ninja.mkdir(dirname)
		_p('ifeq (posix,$(SHELLTYPE))')
		_p('\t$(SILENT) mkdir -p %s', dirname)
		_p('else')
		_p('\t$(SILENT) mkdir $(subst /,\\\\,%s)', dirname)
		_p('endif')
	end


	function ninja.mkdirRules(dirname)
		_p('')
		_p('%s:', dirname)
		_p('\t@echo Creating %s', dirname)
		ninja.mkdir(dirname)
	end


	function ninja.per_cfg(cfg, id)
		if id:byte(1) == string.byte('$', 1) then
			return '$' .. cfg.shortname .. "_" .. id:sub(2, #id)
		else
			return cfg.shortname .. "_" .. id
		end
	end


	function ninja.settings(cfg, toolset)
		if #cfg.makesettings > 0 then
			for _, value in ipairs(cfg.makesettings) do
				p.outln(value)
			end
		end

		local value = toolset.getmakesettings(cfg)
		if value then
			p.outln(value)
		end
	end

	function ninja.preBuildCmds(cfg, toolset)
		taki.buildCmds(cfg, "prebuild")
	end


	function ninja.preLinkCmds(cfg, toolset)
		taki.buildCmds(cfg, "prelink")
	end


	function ninja.postBuildCmds(cfg, toolset)
		taki.buildCmds(cfg, "postbuild")
	end


	function ninja.targetDirRules(cfg, toolset)
		ninja.mkdirRules("$(TARGETDIR)")
	end


	function ninja.objDirRules(cfg, toolset)
		ninja.mkdirRules("$(OBJDIR)")
	end


	function ninja.phonyRules(prj)
		--[[
		_p('.PHONY: clean prebuild')
		_p('')
		--]]
	end


	function ninja.shellType()
		--[[
		_p('SHELLTYPE := posix')
		_p('ifeq (.exe,$(findstring .exe,$(ComSpec)))')
		_p('\tSHELLTYPE := msdos')
		_p('endif')
		_p('')
		--]]
	end


	function ninja.rules(cfg, toolset)
		--log:write('ninja.rules -> ' .. '*********************************************************************' .. '\n')
		_p('')
		_p('# Rules')
		_p('# #############################################')

        local template = cfg._taki.template
        local rules = nil
        if template then
            rules = cfg._taki.template.rules
        else
            rules = {}
        end

        local sortedRules = table.keys(rules)
        table.sort(sortedRules, function(lhs, rhs) return rules[lhs].name < rules[rhs].name end)

        local function default(token)
			return '$' .. token
			--return '[' .. token .. ']'
		end

		for _,filename in ipairs(sortedRules) do
			local rule = rules[filename]

			--log:write('ninja.rules -> ' .. rule.name .. '\n')
			_p('')
			_p('rule ' .. rule.name)

			local outputs = rule.outputs or {}
			local context = {
				--['in']	= '$in',
				--['out'] = '$out',
				--['out1'] = '$out1',
			}

			if rule.deps then
				_p('  ' .. 'deps = ' .. rule.deps)
			end

			if rule.depfile then
				local depfile = u.resolve(rule.depfile, context, default)
				_p('  ' .. 'depfile = ' .. depfile)
			end

			if rule.commands then
				local commands = rule.commands
				--log:write('ninja.rules -> ' .. '*********************************************************************' .. '\n')
				--log:write('ninja.rules -> ' .. inspect(commands) .. '\n')
				
				commands = taki.map(commands, u.resolve, context, default)
				--log:write('ninja.rules -> ' .. inspect(commands) .. '\n')

				ninja.processAndOutputCommands(cfg, commands)
			end
		end

		_p('')
		_p('rule custom')
		_p('  command = custom')
	end


	function ninja.variables(cfg, toolset)
        if not cfg._taki.template or not cfg._taki.template.variables then
            return
        end

		_p('')
		_p('# Variables')
		_p('# #############################################')
		_p('')
		--p.outln(ninja.per_cfg(cfg, 'TARGETDIR') .. ' = ' .. project.getrelative(cfg.project, cfg.buildtarget.directory))
		--p.outln(ninja.per_cfg(cfg, 'TARGET') .. ' = ' .. ninja.per_cfg(cfg, '$TARGETDIR') .. '/' .. cfg.buildtarget.name)
		
		local variables = cfg._taki.template.variables

		local context = {}
		local function default(token)
			return '$' .. ninja.per_cfg(cfg, token)
		end 
		local function resolve(str)
			return u.resolve(str, context, default)
		end

		for _, variable in ipairs(variables.keys) do
			_p(ninja.per_cfg(cfg, variable) .. ' = ' .. resolve(variables.table[variable]))		
		end
	end

    --[[
	function ninja.objdir(cfg, toolset)
		_p(ninja.per_cfg(cfg, 'OBJDIR') .. ' = ' .. project.getrelative(cfg.project, cfg.objdir))
	end
    --]]

--
-- Output the file compile targets.
--

    ninja.elements.targets = function(cfg)
        local funcs = {}

        table.insert(funcs, function(cfg, toolset)
            _p('')
            _p('# Targets for ' .. cfg.shortname)
            _p('# #############################################')
        end)

        table.insert(funcs, function(cfg, toolset)
            ninja.preBuildTarget(cfg, toolset)
        end)

        table.insert(funcs, function(cfg, toolset)
            ninja.outputMainTarget(cfg, toolset)
        end)

        table.insert(funcs, function(cfg, toolset)
            ninja.outputLinkTarget(cfg, toolset)
        end)

        table.insert(funcs, function(cfg, toolset)
            ninja.outputPchTarget(cfg, toolset)
        end)

        for _, fileRule in ipairs(cfg._taki.fileRules) do
            table.insert(funcs, function(cfg, toolset)
                ninja.outputFileRules(cfg, fileRule)
            end)
        end
        
        return funcs
    end


    function ninja.outputTargetSection(prj)
        _p('')
        _p('# Targets')
        _p('# #############################################')

        taki.outputSection(prj, ninja.elements.targets)
    end


    function ninja.outputLinkTarget(cfg, toolset)
        if cfg._taki.template and cfg._taki.template.main then
            ninja.outputFileRules(cfg, cfg._taki.template.main)
        end
    end


    function ninja.outputPchTarget(cfg, toolset)
        if cfg._taki.template and cfg._taki.template.pch then
            ninja.outputFileRules(cfg, cfg._taki.template.pch)
        end		
    end


	function ninja.processMultipleCommands(cfg, commands)
		if not commands or #commands == 0 then
			return nil
		end
		if #commands == 1 then
			return commands
		else
			local cmds = {}
			if cfg.system == p.WINDOWS then
				table.insert(cmds, 'cmd /S /C "$')
				for i, command in ipairs(commands) do
					table.insert(cmds, command .. iif(i < #commands, ' &&', '' ) .. ' $')
				end
				table.insert(cmds, '"')
			else
				for i, command in ipairs(commands) do
					table.insert(cmds, command .. iif(i < #commands, ' ;', '' ) .. ' $')
				end
			end
			return cmds
		end
	end
	
	
	local function outputVariable(variable, values)
		if not (type(values) == 'table') then
			values = { values }
		end 

		local spaces = '  '
		_p(spaces .. variable .. ' = ' .. values[1])
		spaces = spaces .. string.rep(' ', variable:len()) .. '   '
		for i = 2, #values do
			_p(spaces .. values[i])
		end
	end

	
	function ninja.processAndOutputCommands(cfg, commands)
		commands = os.translateCommandsAndPaths(commands, cfg.project.basedir, cfg.project.location)
		commands = taki.processBinDirs(cfg, commands)
		commands = ninja.processMultipleCommands(cfg, commands)

		outputVariable('command', commands)
	end

	--[[
	function ninja.preBuildTarget(cfg, toolset)
		if not cfg.prebuildcommands or #cfg.prebuildcommands == 0 then
			return
		end

		local target = ninja.per_cfg(cfg, cfg.project.name .. '_prebuild')

		_p('')
		_p('build ' .. target .. ': custom')

		local cmds = taki.buildCmds(cfg, 'prebuild')
		ninja.processAndOutputCommands(cfg, cmds)
	end
	--]]

	-- +toto+2024.02.20 : check
	function ninja.preBuildTarget(cfg, toolset)
		if not cfg.prebuildcommands or #cfg.prebuildcommands == 0 then
			return
		end

		local target = ninja.per_cfg(cfg, cfg.project.name .. '_prebuild')

		local cmds = taki.buildCmds(cfg, 'prebuild')
		ninja.processAndOutputCommands(cfg, cmds)

		local fileRule = {
			name 		= 'custom',

			commands 	= cmds,
			outputs 	= { target }
		}

		ninja.outputFileRules(cfg, fileRule)
	end


	function ninja.outputMainTarget(cfg, toolset)
        local inputs = {}

        if cfg._taki.template and cfg._taki.template.main then
            inputs = cfg._taki.template.main.outputs
        end

		local customs = cfg._taki.filesets['CUSTOM']
		inputs = table.join(inputs, customs)

		local mainTarget = cfg.project.name .. '_%{cfg.shortname}_ALL'

		local fileRule = {
			name 			= 'phony',

			inputs		  	= inputs,
			outputs 		= { mainTarget },			
		}

		ninja.outputFileRules(cfg, fileRule)
	end

--
-- Write out the settings for a particular configuration.
--

    ninja.elements.configuration = function(cfg)
        return {
            ninja.rules,
            ninja.variables,
            --taki.objdir,
            --ninja.bindirs,
            --ninja.exepaths,
            ninja.settings,
            ninja.preBuildCmds,
            ninja.preLinkCmds,
            ninja.postBuildCmds,
        }
    end


    function ninja.outputConfigurationSection(prj)
        taki.outputSection(prj, ninja.elements.configuration)
    end


	function ninja.outputFileRules(cfg, fileRule)
		-- inputs
		-- dependencies
		-- orderOnlyDependencies
		-- outputs
		-- implicitOutputs
		-- variables
		
		local template = cfg._taki.template or {}
		local globals = template.variables or {}
		local context = {
            cfg = { shortname = cfg.shortname, },
			CFLAGS = '$CFLAGS',
			CPPFLAGS = '$CPPFLAGS',
		}
		if cfg._taki.template then
			--context.TARGETDIR = globals.TARGETDIR
		end
		local function default(token)
			if globals.table[token] then
				return '$' .. ninja.per_cfg(cfg, token)
			else
				return 'not-found[' .. token .. ']'
			end
		end
		
		local function path(file)
			file = ninja.path(cfg, file)
			file = u.resolve(file, context, default)
			return file
		end

		local function renamePathsAndConcat(prefix, files)
			files = taki.map(files, path)
			if #files > 0 then
				files = prefix .. table.concat(files, ' ')
			else
				files = ''
			end
			return files	
		end

		local inputs = renamePathsAndConcat( '', fileRule.inputs or {})
		local dependencies = renamePathsAndConcat(' | ', fileRule.dependencies or {})
		local orderOnlyDependencies = renamePathsAndConcat(' || ', fileRule.orderOnlyDependencies or {})
		
		local output = path(fileRule.outputs[1])
		local otherOutputs = {}
		table.move(fileRule.outputs, 2, #fileRule.outputs, 1, otherOutputs)
		local implicitOutputs = renamePathsAndConcat(' | ', table.join(otherOutputs, fileRule.implicitOutputs) or {})
		
		log:write('ninja.addRuleFile -> output -> ' .. inspect(output) .. '\n')

		local ruleName = (function()
            if fileRule.name then
                return fileRule.name
            elseif fileRule.rule then
				return fileRule.rule.name
			else
				return 'custom'
			end
		end)()

		_p('')
		_p('build ' .. output .. implicitOutputs .. ': ' .. ruleName .. ' ' .. inputs .. dependencies .. orderOnlyDependencies)

		if fileRule.commands then
			-- custom build
			ninja.processAndOutputCommands(cfg, fileRule.commands)
		end

		for i = 1, #otherOutputs do
			local output = path(otherOutputs[i])
			outputVariable('$out' .. tostring(i), output)
		end

		local locals = fileRule.variables
		if locals then
			for _, name in ipairs(locals.keys) do
				local value = locals.table[name]
				value = u.resolve(value, context, default)
				outputVariable(name, value)			
			end
		end

		local message = fileRule.message
		if message then
			outputVariable('description', message)
		end
	end

    --[[
 	function ninja.bindirs(cfg, toolset)
		local dirs = taki.path(cfg, cfg.bindirs)
		if #dirs > 0 then
			p.outln(ninja.per_cfg(cfg, 'EXECUTABLE_PATHS') .. '  = "' .. table.concat(dirs, ":") .. '"')
		end
	end


	function ninja.exepaths(cfg, toolset)
		local dirs = taki.path(cfg, cfg.bindirs)
		if #dirs > 0 then
			p.outln('EXE_PATHS = export PATH=$(EXECUTABLE_PATHS):$$PATH;')
		end
	end
    --]]

